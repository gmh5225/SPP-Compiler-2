# Memory safety
- Memory safety is a core feature of the language.
- Compile time memory checks are ran to prevent any runtime memory issues.

<BR>

### Null pointer dereference
- No concept of "pointers" -- abstracted away into owned objects and borrows (safer concepts).
- Ownership tracking ensures that uninitialized or moved objects aren't used.
- References are always valid because they are only taken at function call sites.
- Inadvertently prevents pointer arithmetic from being possible either (dangerous operation).

<BR>

### Use after free, double free & dangling borrows
- A "freed object" is moved into something else => memory enforcer recognizes this as a non-owned object.
- Cannot use a non-owned object -> ownership tracking ensures that objects are not used after they are "freed".
- References are only taken at call-sites, so it isn't possible for teh underlying object to be freed.

<BR>

### Out-of-bounds access & buffer underflow / overflow
- All low level memory access is bound checked in the `std::mem_seq<T>` class (from `std::allocator<T>`)
- Bound checks can result in errors -> return `std::result<T, std::mem_error>` type

<BR>

### Memory leaks
- Objects are uniquely owned => falls out of scope, then it is automatically freed after destructor is called.
- Memory leaks cannot occur, as the object will automatically be de-allocated upon destruction.
- Impossible to create a memory leak with borrows, as they are borrowed and never invalidated.
- Once the borrow falls out of scope, it is automatically freed, and the object is still valid.
- When the object falls out of scope, there will never be any active borrows to it.

<BR>

### Use uninitialized variables
- Variables that are uninitialized are not usable -- memory enforcer, models uninitialized variables as "non-owned".
- Until variables are assigned some value, they cannot be used.
- At construction, all class attributes must be initialized (from the struct initialization).

<BR>

### Type casting
- Requires a method on the target class to cast to the target type.
- For example, `let a = "123".to_int();` is the `std::Num` cast method.
- Some common casts are in classes to super-impose, ie `std::ToString`, which contains the method `.to_string()`.

<BR>

### Data races
- Only 1 mutable borrow can ever be active per owned object at 1 time
- Temporary ownership can be transferred with a mutable borrow.
- Any number of const borrows can be taken, because read-only objects/borrows are thread-safe.
- Cannot take a mutable and immutable borrow to the same object at the same time.
- Once the mutable borrow falls out of scope, another mutable borrow can be taken.

<BR>

### Deadlocks
TODO: explain how this is mitigated

<BR>

### Stack overflow
There are certain optimizations that can be made to mitigate stack overflow, such as tail call optimization which
are used to reduce the strain on the stack. However, the memory enforcer also ensures that the stack is never
overflowed by tracking the size of the stack, and ensuring that it is never exceeded. The `std::allocator<T>`
returns an `std::result<T, E>` type, which can be checked at runtime to ensure that the stack is not exceeded.

If the stack does exceed at runtime, then there will be a runtime error, because the device simply cannot allocate
any more memory. This is a fatal error, and the program will crash. However, before this happens, a number of
actions will take place to try and prevent this from happening.

References are stored on the stack, unless they are moved into an attribute for example, to extend their lifetime,
in which case they are stored on the heap. This means that the stack is only used for local variables, and so the
stack size is only ever as large as the number of local variables in a function, allowing for the stack to rarely
overflow.


<BR>

### Heap overflow
TODO: explain how this is mitigated

<BR>



## Ownership

Ownership is a core S++ feature, that allows for the compiler to enforce a high level of memory safety. There are a
number of rules and lemmas that are enforced by the compiler, which are detailed below.

1. All objects are uniquely owned -> assignment/function call/subscript is a destructive move
2. All objects are immutable by default -> mutable keyword must be used to make an object mutable
3. All 'let' statements with a value are "owned" by their enclosing scope
4. All class attributes must be initialized on construction
5. Only 1 mutable borrow to an object or its attributes can exist at a time
6. N immutable borrows to an object or its attributes can exist at a time
7. Cannot have a mutable borrow and immutable borrow to an object or its attributes at the same time
8. Moves cannot occur from a borrowed context, only from an owned context (partial move)
9. Cannot do anything with a "non-owned" object except assign it a value to make it "owned"
10. Every memory access operation is bound checked

<BR>

#### Rule #1
- Unique ownership is enforced by the compiler, and is a core feature of the language.
- Every assignment from an owned object to another object is a destructive move.
- Every function call that takes an owned object as a parameter is a destructive move.
- Every subscript operation that takes an owned object as a parameter is a destructive move.
- Prevents a number of memory-related errors from ever occurring at runtime.

<BR>

#### Rule #2
- All objects are immutable by default, and must be explicitly marked as mutable.
- Forces a declaration on mutable objects, which makes it easier to track them.
- Encourages the use of immutable objects, which are safer to use and thread-safe.
- Allows compiler to optimize more aggressively -- mutables require more checks.

<BR>

#### Rule #3
- All 'let' statements with a value are "owned" by their enclosing scope.
- Their value is "moved" into the variable, and the scope owns the variable.
- The lifetime of the variable is the same as the lifetime of the enclosing scope.

<BR>

- All 'let' statements without a value are "non-owned".
- The variable is uninitialized, and cannot be used until it is assigned a value (ownership tracking).
- The lifetime of the variable is the same as the lifetime of the enclosing scope.

<BR>

#### Rule #4
- All class attributes must be initialized on construction.
- Attributes can be initialized with default values on declaration, or in the struct initializer.
- Prevents uninitialized attributes from being used, which can cause memory-related errors.

<BR>

#### Rule #5
- Only 1 mutable borrow to an object or its attributes can exist at a time.
- Prevents multiple mutable borrows from causing memory-related errors (data races).
- Acts as temporary ownership transfer, which allows for mutation of the object.
- A mutable borrow cannot concurrently exist with an immutable borrow.

<BR>

#### Rule #6
- N immutable borrows to an object or its attributes can exist at a time.
- Immutable borrows do not prevent other immutable borrows from occurring.
- Immutable borrows are thread-safe, and can be used to share data across threads.
- Immutable borrows cannot concurrently exist with a mutable borrow

<BR>

#### Rule #7
- Cannot have a mutable borrow and immutable borrow to an object or its attributes at the same time.
- Prevents multiple mutable borrows from causing memory-related errors (data races).
- Enforces with borrow-tracking in the compiler.

<BR>

#### Rule #8
- Moves cannot occur from a borrowed context
- Prevents a move from occurring while a borrow is active, which would invalidate the borrow.
- An attribute can be moved from an owned context only, resulting in a "partial move".
- A partial move is a move of a single attribute, which leaves the object in a valid but non-usable state.
- Moved attributes can be re-initialized with a new value, to allow the object to be moved or borrowed from again.

<BR>

#### Rule #9
- Cannot do anything with a "non-owned" object except assign it a value to make it "owned".
- A non-owned object is either uninitialized, or has been moved from.
- Prevents a number of memory-related errors from ever occurring at runtime.
- Can be re-initialized with a new value, to allow the object to be moved or borrowed from again.

<BR>

#### Rule #10
- Every memory access operation is bound checked.
- Prevents a number of memory-/buffer-related errors from ever occurring at runtime.

<BR>

## Borrowing
- Borrows can be immutable or mutable
- Refer to rules **#5**, **#6**, and **#7** for more information on borrowing
- Borrows are tracked by the compiler, and enforced at compile-time

<BR>

#### Immutable Borrow - `&object`
- Immutable borrows are thread-safe, and can be used to share data across threads.
    - Immutable borrows are read-only
    - For an immutable borrow to exist, there must be no active mutable borrows => no writing can happen
- Immutable borrows can come from owned objects or immutable borrows.
    - Immutable borrows to an immutable borrow are allowed, and borrow from the owned object.
    - So the owned object's borrow count increments; borrows don't have their own borrow count.
- Immutable borrows invalidate previously declared mutable borrows to the owned object.
    - Cannot use the mutable reference to mutate the object while an immutable borrow exists.
    - Creates the thread-safe aspect of having N immutable borrows at any 1 time.
- Immutable borrows do not invalidate previously declared immutable borrows to the owned object.
    - Allows for N active immutable borrows to an object or its attributes at any 1 time.
    - Immutable borrows are read-only, so they do not interfere with each other.
- Immutable borrows cannot be used to mutate, only read, the owned object or its attributes.
    - Read-only access to the owned object or its attributes is allowed.
    - Prevents a number of memory-related errors from ever occurring at runtime.
- Immutable borrows to an immutable borrow are allowed, and borrow from the owned object.
    - Allow for a borrow to be duplicated, whilst leaving the original borrow valid.
    - Increments the owned object's borrow count.
- Immutable borrows cannot be takes from a partially moved object.
    - Prevents a number of memory-related errors from ever occurring at runtime.

<BR>

#### Mutable Borrow - `&mut object`
- Mutable borrows are not thread-safe, and cannot be used to share data across threads.
- Mutable borrows can only come from owned objects.
- Mutable borrows invalidate all previously declared borrows to the owned object.
- Mutable borrows can be used to mutate or read from the owned object or its attributes.
- Mutable borrows to an immutable borrow are not allowed.
- Mutable borrows to a mutable borrow are not allowed.
- Mutable borrows cannot be takes from a partially moved object.

<BR>

### Variables
#### Immutable Borrow - `&variable`
- Immutable borrow to an owned variable is $\textcolor{green}{\textsf{allowed}}$.
- Immutable borrow to an immutable reference is $\textcolor{green}{\textsf{allowed}}$.
- Immutable borrow to a mutable reference is $\textcolor{red}{\textsf{not allowed}}$.
- Immutable borrow to a partially moved object is $\textcolor{red}{\textsf{not allowed}}$.

<BR>

- Immutable borrow to a variable $\textcolor{green}{\textsf{does not}}$ invalidate any previously declared immutable borrows to the owned object.
- Immutable borrow to a variable $\textcolor{red}{\textsf{does}}$ invalidate any previously declared mutable borrows to the owned object.

<BR>

#### Mutable Borrow - `&mut variable`
- Mutable borrow to an owned variable is $\textcolor{green}{\textsf{allowed}}$.
- Mutable borrow to an immutable reference is $\textcolor{red}{\textsf{not allowed}}$.
- Mutable borrow to a mutable reference is $\textcolor{red}{\textsf{not allowed}}$.
- Mutable borrow to a partially moved object is $\textcolor{red}{\textsf{not allowed}}$.

<BR>

- Mutable borrow to a variable $\textcolor{red}{\textsf{does}}$ invalidate any previously declared immutable borrows to the owned object.
- Mutable borrow to a variable $\textcolor{red}{\textsf{does}}$ invalidate any previously declared mutable borrows to the owned object.

<BR>

### Attributes
#### Immutable Borrow - `&object.attribute`
- Immutable borrow to an attribute of an owned object is $\textcolor{green}{\textsf{allowed}}$.
- Immutable borrow to an attribute of an immutable reference is $\textcolor{green}{\textsf{allowed}}$.
- Immutable borrow to an attribute of a mutable reference is $\textcolor{green}{\textsf{allowed}}$.
- Immutable borrow to an attribute of a partially moved object is $\textcolor{green}{\textsf{allowed}}$.

<BR>

- Immutable borrow to an attribute $\textcolor{green}{\textsf{does not}}$ invalidate any previously declared immutable borrows to the owned object.
- Immutable borrow to an attribute $\textcolor{green}{\textsf{does not}}$ invalidate any previously declared immutable borrows to the attribute.
- Immutable borrow to an attribute $\textcolor{red}{\textsf{does}}$ invalidate a previously declared mutable borrow to the owned object.
- Immutable borrow to an attribute $\textcolor{red}{\textsf{does}}$ invalidate a previously declared mutable borrow to the attribute.

<BR>

#### Mutable Borrow - `&mut object.attribute`
- Mutable borrow to an attribute of an owned object is $\textcolor{green}{\textsf{allowed}}$.
- Mutable borrow to an attribute of an immutable reference is $\textcolor{red}{\textsf{not allowed}}$.
- Mutable borrow to an attribute of a mutable reference is $\textcolor{red}{\textsf{not allowed}}$.
- Mutable borrow to an attribute of a partially moved object is $\textcolor{green}{\textsf{allowed}}$.

<BR>

- Immutable borrow to an attribute $\textcolor{red}{\textsf{does}}$ invalidate any previously declared immutable borrows to the owned object.
- Immutable borrow to an attribute $\textcolor{red}{\textsf{does}}$ invalidate any previously declared immutable borrows to the attribute.
- Immutable borrow to an attribute $\textcolor{red}{\textsf{does}}$ invalidate a previously declared mutable borrow to the owned object.
- Immutable borrow to an attribute $\textcolor{red}{\textsf{does}}$ invalidate a previously declared mutable borrow to the attribute.

<BR>

### Functions' Return Values
#### Immutable Borrow - `&object.method()`
- Immutable borrow to a function's owned object return value is $\textcolor{green}{\textsf{allowed}}$.
    - Lifetime elision will extend the temporary value's lifetime t match the reference's.
- Immutable borrow to a function's immutable reference return value is $\textcolor{green}{\textsf{allowed}}$.
- Immutable borrow to a function's mutable reference return value is $\textcolor{red}{\textsf{not allowed}}$.
- Immutable borrow to a function's partially moved object return value is $\textcolor{orange}{\textsf{not possible}}$.

<BR>

#### Mutable Borrow - `&mut object.method()`
- Mutable borrow to a function's owned object return value is $\textcolor{green}{\textsf{allowed}}$.
    - Lifetime elision will extend the temporary value's lifetime t match the reference's.
- Mutable borrow to a function's immutable reference return value is $\textcolor{red}{\textsf{not allowed}}$.
- Mutable borrow to a function's mutable reference return value is $\textcolor{red}{\textsf{not allowed}}$.
- Mutable borrow to a function's partially moved object return value is $\textcolor{orange}{\textsf{not possible}}$.

<BR>

## Consuming vs Borrowing
#### Assignment
- `let a = b;` consumes `b` and assigns it to `a`.
- `let a = &b;` borrows `b` and assigns it to `a`.
- `let a = &mut b;` mutably borrows `b` and assigns it to `a`.

<BR>

#### Function Calls
- `function(a);` consumes `a` and passes it to `function`.
- `function(&a);` borrows `a` and passes it to `function`.
- `function(&mut a);` mutably borrows `a` and passes it to `function`.

<BR>

#### Method Calls
- `fun method(self: self_t) -> std::void` consumes `self` and passes it to `method`.
- `fun method(self: &self_t) -> std::void` borrows `self` and passes it to `method`.
- `fun method(self: &mut self_t) -> std::void` mutably borrows `self` and passes it to `method`.

<BR>

#### Return Values
- `let a = function();` consumes the return value of `function` and assigns it to `a`.
- `let a = &function();` borrows the return value of `function` and assigns it to `a`.
- `let a = &mut function();` mutably borrows the return value of `function` and assigns it to `a`.

<BR>

#### For loop
- `for i in a` consumes `a` and iterates over it.
    - `i` is an owned value => $\textcolor{green}{\textsf{allowed}}$
    - no point immutably borrowing `i` when it's container is moved => $\textcolor{red}{\textsf{not allowed}}$
    - no point mutably borrowing `i` when it's container is moved => $\textcolor{red}{\textsf{not allowed}}$
- `for i in &a` borrows `a` and iterates over it.
    - `i` is an immutable reference to the current element => $\textcolor{green}{\textsf{allowed}}$
    - `i` cannot be an owned object (cannot move from a borrowed context) => $\textcolor{red}{\textsf{not allowed}}$
    - `i` cannot be a mutable reference (cannot mutate an immutable container => `for mut i in &a` => $\textcolor{red}{\textsf{not allowed}}$)
- `for i in &mut a` mutably borrows `a` and iterates over it.
    - `i` is an immutable reference to the current element => $\textcolor{green}{\textsf{allowed}}$
    - `i` cannot be an owned object (cannot move from a borrowed context) => $\textcolor{red}{\textsf{not allowed}}$
- `for mut i in &mut a` mutably borrows `a` and iterates over it.
    - `i` is a mutable reference to the current element => $\textcolor{green}{\textsf{allowed}}$
    - `i` cannot be an owned object (cannot move from a borrowed context) => $\textcolor{red}{\textsf{not allowed}}$

<BR>

### Borrow quick reference
An immutable borrow is a non-owning view over an owned object. This allows the object to be used in multiple
places without copying it. Immutable borrows can only have their immutable methods called on them, and their
attributes are readonly. If the borrow is immutable, then whatever is holding the mutable borrow becomes a
temporary owner of the object, as they can call methods that will mutate the borrow. Only 1 mutable borrow can
exist per owned object at a time, to prevent things like data races -- see the borrow checker for more details.

The mutability of the object holding the borrow can be different to the mutability of the borrow itself. For
example, an immutable-object holding a mutable-borrow is possible -- this means that the object holding the
borrow cannot be re-assigned to, but mutable method can be called on the borrow itself. A common case of this
is the `self: &mut self_t` seen in methods of a class that mutate it -- the `self` object cannot be re-assigned to,
but the attributes of it, for example, can be mutated from this method.

Mutable borrows can only be taken by objects defined with `let mut ...`, because a mutable borrow needs to be
able to mutate the object. Objects not defined with `mut` can only take immutable borrows, because they cannot be
mutated.

- Assignment
    - `let a = b` - `a` is an immutable-object containing `b`'s value (`b` is consumed into `a`)
    - `let mut a = b` - `a` is a mutable-object containing `b`'s value (`b` is consumed into `a`)
    - `let a = &b` - `a` is an immutable-object containing an immutable-borrow to `b`
    - `let mut a = &b` - `a` is a mutable-object containing an immutable-borrow to `b`
    - `let a = &mut b` - `a` is an immutable-object containing a mutable-borrow to `b`
    - `let mut a = &mut b` - `a` is a mutable-object containing a mutable-borrow to `b`


- Cases for the `for` loop
    - `for a in b` - `b` is consumed, every element is moved into `a`
    - `for a in &b` - `b` is borrowed, every element is borrowd into `a`
    - `for a in &mut b` - `b` is mutably borrowed, every element is immutably borrowed into `a`
    - `for mut a in &mut b` - `b` is mutably borrowed, every element is mutably borrowed into `a`


- Function parameters:
    - `function foo(a: b)` - `a` is an immutable-object of type `b` (argument consumed into parameter)
    - `function foo(mut a: b)` - `a` is a mutable-object of type `b` (argument consumed into parameter)
    - `function foo(a: &b)` - `a` is an immutable-object containing an immutable-borrow to `b`
    - `function foo(mut a: &b)` - `a` is a mutable-object containing an immutable-borrow to `b`
    - `function foo(a: &mut b)` - `a` is an immutable-object containing a mutable-borrow to `b`
    - `function foo(mut a: &mut b)` - `a` is a mutable-object containing a mutable-borrow to `
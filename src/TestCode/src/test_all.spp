mod my_module_root.some_folder.inner_folder.module_name

cls Or {}
sup Or {
    @meta.virtualmethod
    fn or(self: Or, other: Or) -> Self {
        ret self
    }
}

cls Add {}
sup Add {
    @meta.virtualmethod
    fn add(self: Add, other: Add) -> Self {
        ret self
    }
}

cls Default {}
sup Default {
    @meta.virtualmethod
    @meta.staticmethod
    fn default(self: Default) -> Self {
        ret self
    }
}

cls Eq {}
sup Eq {
    @meta.virtualmethod
    fn eq(self: Equal, other: Equal) -> Bool {
        ret true
    }
}

cls Bool {}
sup Eq for Bool {
    fn eq(self: Bool, other: Bool) -> Bool {
        ret true
    }
}

fn main1(a: Num) -> Num {
    ret 1
}
fn main1(a: Str) -> Str {
    ret "1"
}

cls Tup[...Ts] {}

cls Str {
    c: Num
    f: Bool
}

cls Bool {
    b: Num
}

cls SomeType {}

cls Num {
    b: Str
    d: Num
    e: Str
}

cls Vec[T] {
    a: Num
}
sup[T] Vec[T] {
    fn new() -> Vec {
        ret Vec{a=1}
    }
}

sup Or for Bool {
    fn or(self: Bool, other: Bool) -> Bool {
        ret Bool{}
    }
}

sup Default for Num {
    fn default(self: Default) -> Num {
        ret Num {
            b="",
            d=0,
            e="false"
        }
    }
}

sup Default for Str {
    fn default(self: Default) -> Str {
        ret Str {
            c=0,
            f=false
        }
    }
}

sup Add for Num {
    fn add(self: Num, other: Num) -> Num {
        ret Num {
            b="",
            d=0,
            e="false"
        }
    }
}


cls Vec3 {}
sup Vec3 {
    fn new() -> Vec3 {
        ret Vec3 {}
    }
}


cls ClassA {
    a: Vec3
    b: Str
    c: Vec
}

fn function_test_1(a: Num, b: Num, c: Num, d: Num) -> Str {
    let x = 1
    ret "123"
}

fn function_test_1(a: Str) -> Bool {
    ret true
}

fn h(a: Num, b: Num, c: Num, d: Num) -> Bool {
    ret true
}

fn i(a: &Num, b: &Num, c: &Num) -> Num {
    ret 1
}

cls Cont {
    a: Num
    b: Num
    c: Num
    d: Num
}

sup ClassA {
    fn new() -> ClassA {
        let k = 1
        let d = i(&k, &k, &mut k)

        let p = 1
        let q = 1

        let s = ClassA {
            a=Vec3.new(),
            b="",
            c=Vec.new()
        }

        let a = 1
        let mut x0 = function_test_1(1, 2, 3, 4)
        let x1 = function_test_1("false")

        x0 = 1

        let y = a.b.c.e

        let z = 123_124_999

        ret ClassA {
            a=Vec3.new(),
            b="",
            c=Vec.new()
        }
    }
}

sup ClassA {
    @meta.private
    fn add(self: &ClassA, other: ClassA) -> ClassA {
        let p = 123
        let r = p

        ret ClassA {
            a=self.a,
            b=self.b,
            c=self.c
        }
    }
}




fn function_test_2[T, U=T, ...V](a: T, b: U, ...args: V) -> Num where [T, U: Default, T: Vec, T.Item: Copy, V: Num] {
    let y = 1

    let a = y

    let mut qq = (0, 1)
    let mut ww = 0
    let mut ss = 0
    qq, ww, ss = (("2", 3), 3, 5)


    let d = SomeType{}
    let g = if true == {
        0 { "1" }
        1 { "2" }
        else { 3 }
    }

    let h = {
        let x = 1
        let y = 2
        x + y
    }
    ret 1
}

cls Output {
    a: Output
    b: Output
    c: Output
    d: Output
    e: Output
    f: Num
}

sup Output {}

cls OtherType {
    a: Num
    b: Num
}

sup Str {
    fn generate(self: &Num) -> Num {
        let x = 123
        f(&x)
        f(x)

        ret Num {
            b="",
            d=0,
            e="false"
        }
    }
}


fn g() -> Num {
    ret 123
}



fn function_test_3[T](mut a: &mut Num, mut b: Str, c: Vec) -> Str {
    function_test_1(123, "r")
    ret "13"
}

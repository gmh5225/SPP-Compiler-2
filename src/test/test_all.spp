mod my_module_root.some_folder.inner_folder.module_name

use std.vec.Vec
use std.str.Str
use std.num.Num

use std.collections.{Map, Set}
use std.memory.*


cls ClassA {
    a: Vec[Num]
    b: Str
    c: Map[Str, Set[Num]]
}

sup ClassA {
    fn new() -> ClassA {
        let x = function(a)
        let y = a.b.c

        ret ClassA {
            a=vec.new(),
            b="",
            c=map.new()
        }
    }
}

sup std.ops.Add for ClassA {
    fn add(self: &Self, other: ClassA) -> Self {
        ret ClassA {
            a=self.a + other.a,
            b=self.b + other.b,
            c=self.c + other.c
        }
    }
}

enum EnumType {
    variantA,
    variantB,
    variantC
}

@meta.public
fn function_test_1(a: Num, b: Num, c: Num = 0, ...d: Num) -> Num {
    let x = function_test_1(400, 500, c=200)
}


@meta.private[T](900)
@meta.other_decorator(100, "test")
fn function_test_2[T, U=T, ...V](a: Num, ...args: V) -> Num where [T, U: Default, T: Vec, T.Item: Copy, V: Num] if a > 0 {
    let x = function_test_2(400, 500)
    let y = 1 + 2 * 3 - 4 / 5 % 6 ^ 7 & 8 | 9 || 10 && 11 == 12 != 13 < 14 > 15 <= 16 >= 17 |> 18 <| 19

    let a = y
    let b = 1 || "hello" || false || true || (1, 2, 3)
    let c = [&x](x, y) => { x + y }
    let d = SomeType{a, b}
    let e = 0 + ... + args
    let f = function_call(_, 2, 3, _, 5)
    let g = if some_value() == {
        0 => { 1 }
        1 => { 2 }
    }
    let h = {
        let x = 1
        let y = 2
        x + y
    }
}

fn function_test_3(mut a: &mut Self.Output, mut b: std.ns.detail.Type[T].Inner[U, T=Num], c: (T, std.Other.Inner[T].Output, U)) -> Self.Item {
    let x = function_test_3[T](400, 500)

    while true {
        let x = 1
        let y = 2
        x + y
    }

    with x.generate() as y {
        let z = y
    }

    use InnerType as OtherType

    let mut variable = some_function_call() else {
        let x = 1
        let y = 2
        x + y
    }

    {
        let x = 1
        let y = 2
        x + y
    }

    let temp: Str

    let b = function_call()
    let c = a.b.c.d.e.f
    let d = OtherType{a=10, b=20, else=OtherType.def(), sup=(Num.new())}


    yield 1
    yield 2
    ret 3
}
